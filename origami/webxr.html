<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple VR Example with WebXR</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    button { position: absolute; top: 20px; left: 20px; z-index: 100; }
  </style>
</head>
<body>
  <button id="enter-vr">Enter VR</button>
  <canvas id="xr-canvas"></canvas>
  <script>
    const canvas = document.getElementById('xr-canvas');
    const gl = canvas.getContext('webgl', { xrCompatible: true });
    let xrSession = null;
    let xrReferenceSpace = null;
    let animationFrameHandle = null;
    let cubes = [];

    document.getElementById('enter-vr').addEventListener('click', onEnterVR);

    function initWebGL() {
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);

      const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec4 aVertexColor;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying lowp vec4 vColor;
        void main(void) {
          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          vColor = aVertexColor;
        }
      `;

      const fsSource = `
        varying lowp vec4 vColor;
        void main(void) {
          gl_FragColor = vColor;
        }
      `;

      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      const programInfo = {
        program: shaderProgram,
        attribLocations: {
          vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
          vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
        },
        uniformLocations: {
          projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
          modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
        },
      };

      cubes.push(createCube(gl, programInfo, [0.0, 0.0, -5.0]));
      cubes.push(createCube(gl, programInfo, [2.0, 0.0, -5.0]));
      cubes.push(createCube(gl, programInfo, [-2.0, 0.0, -5.0]));

      return programInfo;
    }

    function createCube(gl, programInfo, translation) {
      const positions = [
        -1.0, -1.0,  1.0,
         1.0, -1.0,  1.0,
         1.0,  1.0,  1.0,
        -1.0,  1.0,  1.0,
        -1.0, -1.0, -1.0,
         1.0, -1.0, -1.0,
         1.0,  1.0, -1.0,
        -1.0,  1.0, -1.0,
      ];

      const colors = [
        1.0,  1.0,  1.0,  1.0,
        1.0,  0.0,  0.0,  1.0,
        0.0,  1.0,  0.0,  1.0,
        0.0,  0.0,  1.0,  1.0,
        1.0,  1.0,  0.0,  1.0,
        1.0,  0.0,  1.0,  1.0,
        0.0,  1.0,  1.0,  1.0,
        0.0,  0.0,  0.0,  1.0,
      ];

      const indices = [
        0,  1,  2,      0,  2,  3,
        4,  5,  6,      4,  6,  7,
        0,  1,  5,      0,  5,  4,
        2,  3,  7,      2,  7,  6,
        0,  3,  7,      0,  7,  4,
        1,  2,  6,      1,  6,  5,
      ];

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

      return {
        position: positionBuffer,
        color: colorBuffer,
        indices: indexBuffer,
        vertexCount: indices.length,
        translation: translation,
        rotation: [0, 0, 0],
      };
    }

    function initShaderProgram(gl, vsSource, fsSource) {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
        return null;
      }

      return shaderProgram;
    }

    function loadShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    function onEnterVR() {
      if (navigator.xr) {
        navigator.xr.requestSession('immersive-vr').then((session) => {
          xrSession = session;
          session.addEventListener('end', onSessionEnded);

          const glLayer = new XRWebGLLayer(session, gl);
          session.updateRenderState({ baseLayer: glLayer });

          session.requestReferenceSpace('local').then((refSpace) => {
            xrReferenceSpace = refSpace;
            session.requestAnimationFrame(onXRFrame);
          });
        }).catch((err) => {
          console.error('Failed to enter VR mode:', err);
        });
      } else {
        alert('WebXR not supported');
      }
    }

    function onSessionEnded(event) {
      xrSession = null;
      if (animationFrameHandle) {
        window.cancelAnimationFrame(animationFrameHandle);
        animationFrameHandle = null;
      }
    }

    function onXRFrame(t, frame) {
      const session = frame.session;
      const pose = frame.getViewerPose(xrReferenceSpace);

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      if (pose) {
        const glLayer = session.renderState.baseLayer;

        gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

        for (const view of pose.views) {
          const viewport = glLayer.getViewport(view);
          gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

          const projectionMatrix = view.projectionMatrix;
          const viewMatrix = view.transform.inverse.matrix;

          cubes.forEach((cube) => {
            cube.rotation[0] += 0.01;
            cube.rotation[1] += 0.01;

            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, cube.translation);
            mat4.rotateX(modelViewMatrix, modelViewMatrix, cube.rotation[0]);
            mat4.rotateY(modelViewMatrix, modelViewMatrix, cube.rotation[1]);

            drawCube(gl, cube, projectionMatrix, viewMatrix, modelViewMatrix);
          });
        }
      }

      session.requestAnimationFrame(onXRFrame);
    }

    function drawCube(gl, cube, projectionMatrix, viewMatrix, modelViewMatrix) {
      gl.bindBuffer(gl.ARRAY_BUFFER, cube.position);
      gl.vertexAttribPointer(
          programInfo.attribLocations.vertexPosition,
          3, // numComponents
          gl.FLOAT, //
